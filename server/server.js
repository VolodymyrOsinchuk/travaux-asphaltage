const express = require('express')
const helmet = require('helmet')
const compression = require('compression')
const path = require('path')
require('dotenv').config()

// Import des configurations
const db = require('./models')
// const redisClient = require('./config/redis')

// Import des routes
const indexRoutes = require('./routes/index')
const authRoutes = require('./routes/auth')
const serviceRoutes = require('./routes/services')
const projectRoutes = require('./routes/projects')
const testimonialRoutes = require('./routes/testimonials')
const contactRoutes = require('./routes/contacts')
const blogRoutes = require('./routes/blog')
const uploadRoutes = require('./routes/upload')

// Import des middleware personnalis√©s
const {
  globalErrorHandler,
  notFoundHandler,
  multerErrorHandler,
} = require('./middleware/errorHandler')
const { conditionalCors } = require('./middleware/cors')
const {
  generalLimiter,
  authLimiter,
  readLimiter,
  strictLimiter,
  heavyLimiter,
  speedLimiter,
  logRateLimitHit,
} = require('./middleware/rateLimit')
const logger = require('./middleware/logger')

// Cr√©ation de l'application Express
const app = express()

// Configuration du port
const PORT = process.env.PORT || 5000

// Middleware de s√©curit√© (doit √™tre en premier)
app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", 'data:', 'https:'],
        connectSrc: ["'self'", 'https://api.cloudinary.com'],
        fontSrc: ["'self'", 'https:'],
      },
    },
    crossOriginEmbedderPolicy: false,
  })
)

// Compression des r√©ponses
app.use(compression())

// Configuration CORS avec middleware personnalis√©
app.use(conditionalCors)

// Middleware de logging
if (process.env.NODE_ENV !== 'test') {
  app.use((req, res, next) => {
    logger.info({
      method: req.method,
      url: req.originalUrl,
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      timestamp: new Date().toISOString(),
    })
    next()
  })
}

// Middleware pour log des rate limits
app.use(logRateLimitHit)

// Speed limiter global (appliqu√© en premier)
app.use(speedLimiter)

// Rate limiting global pour les API (moins strict)
app.use('/api/', generalLimiter)

// Middleware pour parser les requ√™tes
app.use(
  express.json({
    limit: '10mb',
    verify: (req, res, buf) => {
      req.rawBody = buf
    },
  })
)
app.use(express.urlencoded({ extended: true, limit: '10mb' }))

// Servir les fichiers statiques
app.use(
  '/uploads',
  express.static(path.join(__dirname, 'uploads'), {
    maxAge: '1d',
    etag: true,
    setHeaders: (res, path) => {
      // S√©curit√© pour les fichiers upload√©s
      res.set('X-Content-Type-Options', 'nosniff')
      res.set('X-Frame-Options', 'DENY')
    },
  })
)

// Configuration pour la production
if (process.env.NODE_ENV === 'production') {
  // Servir les fichiers statiques du client
  app.use(
    express.static(path.join(__dirname, '../client/dist'), {
      maxAge: '1d',
      etag: true,
      setHeaders: (res, path) => {
        // Cache plus long pour les assets avec hash
        if (path.includes('.') && !path.includes('index.html')) {
          res.set('Cache-Control', 'public, max-age=31536000') // 1 an
        }
      },
    })
  )
}

// Routes API avec rate limiting sp√©cifique
app.use('/api', readLimiter, indexRoutes)
app.use('/api/auth', authLimiter, authRoutes)
app.use('/api/services', readLimiter, serviceRoutes)
app.use('/api/projects', readLimiter, projectRoutes)
app.use('/api/testimonials', readLimiter, testimonialRoutes)
app.use('/api/contacts', strictLimiter, contactRoutes)
app.use('/api/blog', readLimiter, blogRoutes)
app.use('/api/upload', uploadRoutes) // Le rate limiting est g√©r√© dans le router

app.get('/', (req, res) => {
  res.send('Hello from backend travaux asphaltage')
})

// Route de sant√© (sans rate limiting)
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV || 'development',
    version: process.env.npm_package_version || '1.0.0',
    memory: {
      used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024) + 'MB',
      total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024) + 'MB',
    },
  })
})

// Route de m√©triques (pour monitoring) avec rate limiting strict
app.get('/metrics', strictLimiter, (req, res) => {
  res.status(200).json({
    memory: process.memoryUsage(),
    uptime: process.uptime(),
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    cpu: process.cpuUsage(),
    version: process.version,
  })
})

// Route pour v√©rifier les limites de rate (utile pour debug)
app.get('/api/rate-limit-info', generalLimiter, (req, res) => {
  res.json({
    success: true,
    rateLimit: {
      limit: req.rateLimit?.limit,
      remaining: req.rateLimit?.remaining,
      reset: req.rateLimit?.reset,
      resetTime: req.rateLimit?.resetTime,
    },
    ip: req.ip,
    timestamp: new Date().toISOString(),
  })
})

// En production, servir l'application React pour toutes les routes non-API
if (process.env.NODE_ENV === 'production') {
  app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, '../client/dist/index.html'))
  })
}

// Middleware de gestion d'erreurs Multer
app.use(multerErrorHandler)

// Middleware pour les routes non trouv√©es
app.use(notFoundHandler)

// Middleware global de gestion d'erreurs (doit √™tre en dernier)
app.use(globalErrorHandler)

// Fonction pour d√©marrer le serveur
async function startServer() {
  try {
    // Test de la connexion √† la base de donn√©es
    await db.sequelize.authenticate()
    console.log('‚úÖ Connexion √† la base de donn√©es √©tablie avec succ√®s.')

    // Synchronisation des mod√®les
    if (process.env.NODE_ENV === 'development') {
      await db.sequelize.sync({ alter: true })
      console.log('‚úÖ Synchronisation des mod√®les termin√©e.')
    } else {
      // En production, v√©rifier que les tables existent
      await db.sequelize.sync({ force: false })
      console.log('‚úÖ V√©rification des mod√®les termin√©e.')
    }

    // Test de la connexion Redis
    try {
      // if (redisClient) {
      //   await redisClient.ping()
      //   console.log('‚úÖ Connexion Redis √©tablie avec succ√®s.')
      // }
    } catch (error) {
      console.warn('‚ö†Ô∏è  Redis non disponible, cache d√©sactiv√©.')
      console.warn('   D√©tails:', error.message)
    }

    // Validation des variables d'environnement critiques
    const requiredEnvVars = ['JWT_SECRET', 'DATABASE_URL']
    const missingVars = requiredEnvVars.filter(
      (varName) => !process.env[varName]
    )

    if (missingVars.length > 0) {
      console.error(
        "‚ùå Variables d'environnement manquantes:",
        missingVars.join(', ')
      )
      process.exit(1)
    }

    // D√©marrage du serveur
    const server = app.listen(PORT, () => {
      console.log(`üöÄ Serveur d√©marr√© sur le port ${PORT}`)
      console.log(`üìç Environnement: ${process.env.NODE_ENV || 'development'}`)
      console.log(`üåê URL: http://localhost:${PORT}`)
      console.log(`üõ°Ô∏è  Rate limiting activ√©`)

      if (process.env.NODE_ENV === 'development') {
        console.log(`üîß API disponible √†: http://localhost:${PORT}/api`)
        console.log(`üíä Health check: http://localhost:${PORT}/health`)
        console.log(`üìä M√©triques: http://localhost:${PORT}/metrics`)
        console.log(
          `üîç Rate limit info: http://localhost:${PORT}/api/rate-limit-info`
        )
      }
    })

    // Configuration des timeouts
    server.timeout = 30000 // 30 secondes
    server.keepAliveTimeout = 5000 // 5 secondes
    server.headersTimeout = 6000 // 6 secondes (sup√©rieur √† keepAliveTimeout)

    // Gestion des connexions pour arr√™t propre
    const connections = new Set()

    server.on('connection', (connection) => {
      connections.add(connection)
      connection.on('close', () => {
        connections.delete(connection)
      })
    })

    // Stocker les connexions pour l'arr√™t propre
    server.connections = connections

    return server
  } catch (error) {
    console.error('‚ùå Erreur lors du d√©marrage du serveur:', error)
    process.exit(1)
  }
}

// Gestion des signaux pour arr√™t propre
process.on('SIGTERM', async () => {
  console.log('üõë Signal SIGTERM re√ßu, arr√™t du serveur...')
  await gracefulShutdown()
})

process.on('SIGINT', async () => {
  console.log('üõë Signal SIGINT re√ßu, arr√™t du serveur...')
  await gracefulShutdown()
})

// Gestion des erreurs non captur√©es
process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Promesse rejet√©e non g√©r√©e:', reason)
  logger.error('Unhandled Promise Rejection:', reason)
  // Ne pas arr√™ter le serveur en d√©veloppement
  if (process.env.NODE_ENV === 'production') {
    process.exit(1)
  }
})

process.on('uncaughtException', (error) => {
  console.error('‚ùå Exception non captur√©e:', error)
  logger.error('Uncaught Exception:', error)
  process.exit(1)
})

// Fonction d'arr√™t propre
async function gracefulShutdown() {
  try {
    console.log('üîÑ Fermeture des connexions...')

    // Fermer le serveur HTTP
    if (global.server) {
      await new Promise((resolve) => {
        global.server.close(resolve)
      })
      console.log('‚úÖ Serveur HTTP ferm√©.')

      // Fermer toutes les connexions actives
      if (global.server.connections) {
        global.server.connections.forEach((connection) => {
          connection.destroy()
        })
        console.log('‚úÖ Connexions HTTP ferm√©es.')
      }
    }

    // Fermer les connexions √† la base de donn√©es
    if (db && db.sequelize) {
      await db.sequelize.close()
      console.log('‚úÖ Connexion base de donn√©es ferm√©e.')
    }

    // Fermer la connexion Redis
    // if (redisClient) {
    //   await redisClient.quit()
    //   console.log('‚úÖ Connexion Redis ferm√©e.')
    // }

    console.log('‚úÖ Arr√™t propre termin√©.')
    process.exit(0)
  } catch (error) {
    console.error("‚ùå Erreur lors de l'arr√™t:", error)
    process.exit(1)
  }
}

// D√©marrage du serveur seulement si ce fichier est ex√©cut√© directement
if (require.main === module) {
  startServer().then((server) => {
    global.server = server
  })
}

module.exports = app
